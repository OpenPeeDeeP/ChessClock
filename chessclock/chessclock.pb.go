// Code generated by protoc-gen-go. DO NOT EDIT.
// source: chessclock.proto

/*
Package chessclock is a generated protocol buffer package.

It is generated from these files:
	chessclock.proto

It has these top-level messages:
	StartRequest
	StartResponse
	StopRequest
	StopResponse
	ScheduleRequest
	ScheduleResponse
	TallyRequest
	TallyResponse
	ListTimeSheetsRequest
	ListTimeSheetsResponse
	ListTagsRequest
	ListTagsResponse
	VersionRequest
	VersionResponse
*/
package chessclock

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type StopRequest_Reason int32

const (
	StopRequest_Break    StopRequest_Reason = 0
	StopRequest_Lunch    StopRequest_Reason = 1
	StopRequest_EndOfDay StopRequest_Reason = 2
)

var StopRequest_Reason_name = map[int32]string{
	0: "Break",
	1: "Lunch",
	2: "EndOfDay",
}
var StopRequest_Reason_value = map[string]int32{
	"Break":    0,
	"Lunch":    1,
	"EndOfDay": 2,
}

func (x StopRequest_Reason) String() string {
	return proto.EnumName(StopRequest_Reason_name, int32(x))
}
func (StopRequest_Reason) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{2, 0} }

type StartRequest struct {
	Timestamp   int64  `protobuf:"varint,1,opt,name=timestamp" json:"timestamp,omitempty"`
	Tag         string `protobuf:"bytes,2,opt,name=tag" json:"tag,omitempty"`
	Description string `protobuf:"bytes,3,opt,name=description" json:"description,omitempty"`
}

func (m *StartRequest) Reset()                    { *m = StartRequest{} }
func (m *StartRequest) String() string            { return proto.CompactTextString(m) }
func (*StartRequest) ProtoMessage()               {}
func (*StartRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *StartRequest) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *StartRequest) GetTag() string {
	if m != nil {
		return m.Tag
	}
	return ""
}

func (m *StartRequest) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

// Empty response but useful if we need a resposne later.
type StartResponse struct {
}

func (m *StartResponse) Reset()                    { *m = StartResponse{} }
func (m *StartResponse) String() string            { return proto.CompactTextString(m) }
func (*StartResponse) ProtoMessage()               {}
func (*StartResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

type StopRequest struct {
	Reason StopRequest_Reason `protobuf:"varint,1,opt,name=reason,enum=chessclock.StopRequest_Reason" json:"reason,omitempty"`
}

func (m *StopRequest) Reset()                    { *m = StopRequest{} }
func (m *StopRequest) String() string            { return proto.CompactTextString(m) }
func (*StopRequest) ProtoMessage()               {}
func (*StopRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *StopRequest) GetReason() StopRequest_Reason {
	if m != nil {
		return m.Reason
	}
	return StopRequest_Break
}

// Empty response but useful if we need a resposne later.
type StopResponse struct {
}

func (m *StopResponse) Reset()                    { *m = StopResponse{} }
func (m *StopResponse) String() string            { return proto.CompactTextString(m) }
func (*StopResponse) ProtoMessage()               {}
func (*StopResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

type ScheduleRequest struct {
	Date int64 `protobuf:"varint,1,opt,name=date" json:"date,omitempty"`
}

func (m *ScheduleRequest) Reset()                    { *m = ScheduleRequest{} }
func (m *ScheduleRequest) String() string            { return proto.CompactTextString(m) }
func (*ScheduleRequest) ProtoMessage()               {}
func (*ScheduleRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *ScheduleRequest) GetDate() int64 {
	if m != nil {
		return m.Date
	}
	return 0
}

type ScheduleResponse struct {
	Tasks []*ScheduleResponse_Task `protobuf:"bytes,1,rep,name=tasks" json:"tasks,omitempty"`
}

func (m *ScheduleResponse) Reset()                    { *m = ScheduleResponse{} }
func (m *ScheduleResponse) String() string            { return proto.CompactTextString(m) }
func (*ScheduleResponse) ProtoMessage()               {}
func (*ScheduleResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *ScheduleResponse) GetTasks() []*ScheduleResponse_Task {
	if m != nil {
		return m.Tasks
	}
	return nil
}

type ScheduleResponse_Task struct {
	Timestamp   int64  `protobuf:"varint,1,opt,name=timestamp" json:"timestamp,omitempty"`
	Tag         string `protobuf:"bytes,2,opt,name=tag" json:"tag,omitempty"`
	Description string `protobuf:"bytes,3,opt,name=description" json:"description,omitempty"`
}

func (m *ScheduleResponse_Task) Reset()                    { *m = ScheduleResponse_Task{} }
func (m *ScheduleResponse_Task) String() string            { return proto.CompactTextString(m) }
func (*ScheduleResponse_Task) ProtoMessage()               {}
func (*ScheduleResponse_Task) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5, 0} }

func (m *ScheduleResponse_Task) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *ScheduleResponse_Task) GetTag() string {
	if m != nil {
		return m.Tag
	}
	return ""
}

func (m *ScheduleResponse_Task) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

type TallyRequest struct {
	Date int64 `protobuf:"varint,1,opt,name=date" json:"date,omitempty"`
}

func (m *TallyRequest) Reset()                    { *m = TallyRequest{} }
func (m *TallyRequest) String() string            { return proto.CompactTextString(m) }
func (*TallyRequest) ProtoMessage()               {}
func (*TallyRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *TallyRequest) GetDate() int64 {
	if m != nil {
		return m.Date
	}
	return 0
}

type TallyResponse struct {
	Tasks []*TallyResponse_Task `protobuf:"bytes,1,rep,name=tasks" json:"tasks,omitempty"`
}

func (m *TallyResponse) Reset()                    { *m = TallyResponse{} }
func (m *TallyResponse) String() string            { return proto.CompactTextString(m) }
func (*TallyResponse) ProtoMessage()               {}
func (*TallyResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *TallyResponse) GetTasks() []*TallyResponse_Task {
	if m != nil {
		return m.Tasks
	}
	return nil
}

type TallyResponse_Task struct {
	Timespan    int64  `protobuf:"varint,1,opt,name=timespan" json:"timespan,omitempty"`
	Tag         string `protobuf:"bytes,2,opt,name=tag" json:"tag,omitempty"`
	Description string `protobuf:"bytes,3,opt,name=description" json:"description,omitempty"`
}

func (m *TallyResponse_Task) Reset()                    { *m = TallyResponse_Task{} }
func (m *TallyResponse_Task) String() string            { return proto.CompactTextString(m) }
func (*TallyResponse_Task) ProtoMessage()               {}
func (*TallyResponse_Task) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7, 0} }

func (m *TallyResponse_Task) GetTimespan() int64 {
	if m != nil {
		return m.Timespan
	}
	return 0
}

func (m *TallyResponse_Task) GetTag() string {
	if m != nil {
		return m.Tag
	}
	return ""
}

func (m *TallyResponse_Task) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

// Empty request but useful if we need parameters later.
type ListTimeSheetsRequest struct {
}

func (m *ListTimeSheetsRequest) Reset()                    { *m = ListTimeSheetsRequest{} }
func (m *ListTimeSheetsRequest) String() string            { return proto.CompactTextString(m) }
func (*ListTimeSheetsRequest) ProtoMessage()               {}
func (*ListTimeSheetsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

type ListTimeSheetsResponse struct {
	Dates []int64 `protobuf:"varint,1,rep,packed,name=dates" json:"dates,omitempty"`
}

func (m *ListTimeSheetsResponse) Reset()                    { *m = ListTimeSheetsResponse{} }
func (m *ListTimeSheetsResponse) String() string            { return proto.CompactTextString(m) }
func (*ListTimeSheetsResponse) ProtoMessage()               {}
func (*ListTimeSheetsResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *ListTimeSheetsResponse) GetDates() []int64 {
	if m != nil {
		return m.Dates
	}
	return nil
}

type ListTagsRequest struct {
	Date int64 `protobuf:"varint,1,opt,name=date" json:"date,omitempty"`
}

func (m *ListTagsRequest) Reset()                    { *m = ListTagsRequest{} }
func (m *ListTagsRequest) String() string            { return proto.CompactTextString(m) }
func (*ListTagsRequest) ProtoMessage()               {}
func (*ListTagsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *ListTagsRequest) GetDate() int64 {
	if m != nil {
		return m.Date
	}
	return 0
}

type ListTagsResponse struct {
	Tags []string `protobuf:"bytes,1,rep,name=tags" json:"tags,omitempty"`
}

func (m *ListTagsResponse) Reset()                    { *m = ListTagsResponse{} }
func (m *ListTagsResponse) String() string            { return proto.CompactTextString(m) }
func (*ListTagsResponse) ProtoMessage()               {}
func (*ListTagsResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *ListTagsResponse) GetTags() []string {
	if m != nil {
		return m.Tags
	}
	return nil
}

// Empty request but useful if we need parameters later.
type VersionRequest struct {
}

func (m *VersionRequest) Reset()                    { *m = VersionRequest{} }
func (m *VersionRequest) String() string            { return proto.CompactTextString(m) }
func (*VersionRequest) ProtoMessage()               {}
func (*VersionRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

type VersionResponse struct {
	Version string `protobuf:"bytes,1,opt,name=version" json:"version,omitempty"`
}

func (m *VersionResponse) Reset()                    { *m = VersionResponse{} }
func (m *VersionResponse) String() string            { return proto.CompactTextString(m) }
func (*VersionResponse) ProtoMessage()               {}
func (*VersionResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *VersionResponse) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func init() {
	proto.RegisterType((*StartRequest)(nil), "chessclock.StartRequest")
	proto.RegisterType((*StartResponse)(nil), "chessclock.StartResponse")
	proto.RegisterType((*StopRequest)(nil), "chessclock.StopRequest")
	proto.RegisterType((*StopResponse)(nil), "chessclock.StopResponse")
	proto.RegisterType((*ScheduleRequest)(nil), "chessclock.ScheduleRequest")
	proto.RegisterType((*ScheduleResponse)(nil), "chessclock.ScheduleResponse")
	proto.RegisterType((*ScheduleResponse_Task)(nil), "chessclock.ScheduleResponse.Task")
	proto.RegisterType((*TallyRequest)(nil), "chessclock.TallyRequest")
	proto.RegisterType((*TallyResponse)(nil), "chessclock.TallyResponse")
	proto.RegisterType((*TallyResponse_Task)(nil), "chessclock.TallyResponse.Task")
	proto.RegisterType((*ListTimeSheetsRequest)(nil), "chessclock.ListTimeSheetsRequest")
	proto.RegisterType((*ListTimeSheetsResponse)(nil), "chessclock.ListTimeSheetsResponse")
	proto.RegisterType((*ListTagsRequest)(nil), "chessclock.ListTagsRequest")
	proto.RegisterType((*ListTagsResponse)(nil), "chessclock.ListTagsResponse")
	proto.RegisterType((*VersionRequest)(nil), "chessclock.VersionRequest")
	proto.RegisterType((*VersionResponse)(nil), "chessclock.VersionResponse")
	proto.RegisterEnum("chessclock.StopRequest_Reason", StopRequest_Reason_name, StopRequest_Reason_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for ChessClock service

type ChessClockClient interface {
	Start(ctx context.Context, in *StartRequest, opts ...grpc.CallOption) (*StartResponse, error)
	Stop(ctx context.Context, in *StopRequest, opts ...grpc.CallOption) (*StopResponse, error)
	Schedule(ctx context.Context, in *ScheduleRequest, opts ...grpc.CallOption) (*ScheduleResponse, error)
	Tally(ctx context.Context, in *TallyRequest, opts ...grpc.CallOption) (*TallyResponse, error)
	ListTimeSheets(ctx context.Context, in *ListTimeSheetsRequest, opts ...grpc.CallOption) (*ListTimeSheetsResponse, error)
	ListTags(ctx context.Context, in *ListTagsRequest, opts ...grpc.CallOption) (*ListTagsResponse, error)
	Version(ctx context.Context, in *VersionRequest, opts ...grpc.CallOption) (*VersionResponse, error)
}

type chessClockClient struct {
	cc *grpc.ClientConn
}

func NewChessClockClient(cc *grpc.ClientConn) ChessClockClient {
	return &chessClockClient{cc}
}

func (c *chessClockClient) Start(ctx context.Context, in *StartRequest, opts ...grpc.CallOption) (*StartResponse, error) {
	out := new(StartResponse)
	err := grpc.Invoke(ctx, "/chessclock.ChessClock/Start", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chessClockClient) Stop(ctx context.Context, in *StopRequest, opts ...grpc.CallOption) (*StopResponse, error) {
	out := new(StopResponse)
	err := grpc.Invoke(ctx, "/chessclock.ChessClock/Stop", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chessClockClient) Schedule(ctx context.Context, in *ScheduleRequest, opts ...grpc.CallOption) (*ScheduleResponse, error) {
	out := new(ScheduleResponse)
	err := grpc.Invoke(ctx, "/chessclock.ChessClock/Schedule", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chessClockClient) Tally(ctx context.Context, in *TallyRequest, opts ...grpc.CallOption) (*TallyResponse, error) {
	out := new(TallyResponse)
	err := grpc.Invoke(ctx, "/chessclock.ChessClock/Tally", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chessClockClient) ListTimeSheets(ctx context.Context, in *ListTimeSheetsRequest, opts ...grpc.CallOption) (*ListTimeSheetsResponse, error) {
	out := new(ListTimeSheetsResponse)
	err := grpc.Invoke(ctx, "/chessclock.ChessClock/ListTimeSheets", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chessClockClient) ListTags(ctx context.Context, in *ListTagsRequest, opts ...grpc.CallOption) (*ListTagsResponse, error) {
	out := new(ListTagsResponse)
	err := grpc.Invoke(ctx, "/chessclock.ChessClock/ListTags", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chessClockClient) Version(ctx context.Context, in *VersionRequest, opts ...grpc.CallOption) (*VersionResponse, error) {
	out := new(VersionResponse)
	err := grpc.Invoke(ctx, "/chessclock.ChessClock/Version", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for ChessClock service

type ChessClockServer interface {
	Start(context.Context, *StartRequest) (*StartResponse, error)
	Stop(context.Context, *StopRequest) (*StopResponse, error)
	Schedule(context.Context, *ScheduleRequest) (*ScheduleResponse, error)
	Tally(context.Context, *TallyRequest) (*TallyResponse, error)
	ListTimeSheets(context.Context, *ListTimeSheetsRequest) (*ListTimeSheetsResponse, error)
	ListTags(context.Context, *ListTagsRequest) (*ListTagsResponse, error)
	Version(context.Context, *VersionRequest) (*VersionResponse, error)
}

func RegisterChessClockServer(s *grpc.Server, srv ChessClockServer) {
	s.RegisterService(&_ChessClock_serviceDesc, srv)
}

func _ChessClock_Start_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChessClockServer).Start(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/chessclock.ChessClock/Start",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChessClockServer).Start(ctx, req.(*StartRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChessClock_Stop_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StopRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChessClockServer).Stop(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/chessclock.ChessClock/Stop",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChessClockServer).Stop(ctx, req.(*StopRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChessClock_Schedule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ScheduleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChessClockServer).Schedule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/chessclock.ChessClock/Schedule",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChessClockServer).Schedule(ctx, req.(*ScheduleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChessClock_Tally_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TallyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChessClockServer).Tally(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/chessclock.ChessClock/Tally",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChessClockServer).Tally(ctx, req.(*TallyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChessClock_ListTimeSheets_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListTimeSheetsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChessClockServer).ListTimeSheets(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/chessclock.ChessClock/ListTimeSheets",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChessClockServer).ListTimeSheets(ctx, req.(*ListTimeSheetsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChessClock_ListTags_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListTagsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChessClockServer).ListTags(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/chessclock.ChessClock/ListTags",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChessClockServer).ListTags(ctx, req.(*ListTagsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChessClock_Version_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VersionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChessClockServer).Version(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/chessclock.ChessClock/Version",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChessClockServer).Version(ctx, req.(*VersionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _ChessClock_serviceDesc = grpc.ServiceDesc{
	ServiceName: "chessclock.ChessClock",
	HandlerType: (*ChessClockServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Start",
			Handler:    _ChessClock_Start_Handler,
		},
		{
			MethodName: "Stop",
			Handler:    _ChessClock_Stop_Handler,
		},
		{
			MethodName: "Schedule",
			Handler:    _ChessClock_Schedule_Handler,
		},
		{
			MethodName: "Tally",
			Handler:    _ChessClock_Tally_Handler,
		},
		{
			MethodName: "ListTimeSheets",
			Handler:    _ChessClock_ListTimeSheets_Handler,
		},
		{
			MethodName: "ListTags",
			Handler:    _ChessClock_ListTags_Handler,
		},
		{
			MethodName: "Version",
			Handler:    _ChessClock_Version_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "chessclock.proto",
}

func init() { proto.RegisterFile("chessclock.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 539 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x94, 0x41, 0x8f, 0xd3, 0x3c,
	0x10, 0x86, 0x93, 0x4d, 0xdb, 0x6d, 0xa6, 0xdd, 0x36, 0x1a, 0x7d, 0x1f, 0x1b, 0xb2, 0x2b, 0x54,
	0x2c, 0x81, 0x2a, 0x81, 0x72, 0x28, 0x08, 0x0e, 0x48, 0x1c, 0xd8, 0x45, 0x5c, 0x56, 0x42, 0x4a,
	0xab, 0x15, 0xdc, 0x30, 0xa9, 0x69, 0xa3, 0xb6, 0x49, 0x88, 0x5d, 0xa4, 0xfd, 0x31, 0x1c, 0xf9,
	0x97, 0x1c, 0x90, 0x1d, 0xa7, 0x89, 0x4b, 0xe9, 0x01, 0x89, 0x9b, 0x3d, 0x7e, 0x33, 0x33, 0xcf,
	0xf8, 0x75, 0xc0, 0x8b, 0x97, 0x8c, 0xf3, 0x78, 0x9d, 0xc5, 0xab, 0x30, 0x2f, 0x32, 0x91, 0x21,
	0xd4, 0x11, 0xf2, 0x09, 0xfa, 0x53, 0x41, 0x0b, 0x11, 0xb1, 0xaf, 0x5b, 0xc6, 0x05, 0x5e, 0x82,
	0x2b, 0x92, 0x0d, 0xe3, 0x82, 0x6e, 0x72, 0xdf, 0x1e, 0xd9, 0x63, 0x27, 0xaa, 0x03, 0xe8, 0x81,
	0x23, 0xe8, 0xc2, 0x3f, 0x19, 0xd9, 0x63, 0x37, 0x92, 0x4b, 0x1c, 0x41, 0x6f, 0xce, 0x78, 0x5c,
	0x24, 0xb9, 0x48, 0xb2, 0xd4, 0x77, 0xd4, 0x49, 0x33, 0x44, 0x86, 0x70, 0xa6, 0x2b, 0xf0, 0x3c,
	0x4b, 0x39, 0x23, 0x1c, 0x7a, 0x53, 0x91, 0xe5, 0x55, 0xc5, 0x17, 0xd0, 0x29, 0x18, 0xe5, 0x59,
	0xaa, 0xca, 0x0d, 0x26, 0x0f, 0xc2, 0x46, 0xc3, 0x0d, 0x61, 0x18, 0x29, 0x55, 0xa4, 0xd5, 0xe4,
	0x29, 0x74, 0xca, 0x08, 0xba, 0xd0, 0x7e, 0x53, 0x30, 0xba, 0xf2, 0x2c, 0xb9, 0xbc, 0xd9, 0xa6,
	0xf1, 0xd2, 0xb3, 0xb1, 0x0f, 0xdd, 0xb7, 0xe9, 0xfc, 0xfd, 0x97, 0x6b, 0x7a, 0xe7, 0x9d, 0x90,
	0x81, 0xe4, 0x94, 0xb9, 0x74, 0x13, 0x8f, 0x60, 0x38, 0x8d, 0x97, 0x6c, 0xbe, 0x5d, 0xb3, 0xaa,
	0x11, 0x84, 0xd6, 0x9c, 0x0a, 0xa6, 0xa9, 0xd5, 0x9a, 0xfc, 0xb0, 0xc1, 0xab, 0x75, 0xe5, 0xb7,
	0xf8, 0x12, 0xda, 0x82, 0xf2, 0x15, 0xf7, 0xed, 0x91, 0x33, 0xee, 0x4d, 0x1e, 0x1a, 0x0d, 0xef,
	0x89, 0xc3, 0x19, 0xe5, 0xab, 0xa8, 0xd4, 0x07, 0x1f, 0xa0, 0x25, 0xb7, 0xff, 0x60, 0xc8, 0x04,
	0xfa, 0x33, 0xba, 0x5e, 0xdf, 0x1d, 0x63, 0xf9, 0x6e, 0xc3, 0x99, 0x16, 0x69, 0x90, 0xe7, 0x26,
	0x88, 0x31, 0x79, 0x43, 0x69, 0x50, 0xdc, 0x6a, 0x8a, 0x00, 0xba, 0xaa, 0xe9, 0x9c, 0xa6, 0xba,
	0xce, 0x6e, 0xff, 0x57, 0x0c, 0xe7, 0xf0, 0xff, 0x4d, 0xc2, 0xc5, 0x2c, 0xd9, 0xb0, 0xe9, 0x92,
	0x31, 0xc1, 0x35, 0x0c, 0x09, 0xe1, 0xde, 0xfe, 0x81, 0x06, 0xf8, 0x0f, 0xda, 0x12, 0xad, 0x04,
	0x70, 0xa2, 0x72, 0x23, 0xef, 0x56, 0xe9, 0xe9, 0x82, 0x1f, 0x9b, 0xc7, 0x63, 0xf0, 0x6a, 0x99,
	0x4e, 0x88, 0xd0, 0x12, 0x74, 0x51, 0xe6, 0x73, 0x23, 0xb5, 0x26, 0x1e, 0x0c, 0x6e, 0x59, 0xc1,
	0x93, 0x2c, 0xad, 0x1a, 0x7a, 0x02, 0xc3, 0x5d, 0x44, 0x7f, 0xe8, 0xc3, 0xe9, 0xb7, 0x32, 0xa4,
	0x6a, 0xb8, 0x51, 0xb5, 0x9d, 0xfc, 0x74, 0x00, 0xae, 0xe4, 0x5c, 0xaf, 0xe4, 0x5c, 0xf1, 0x35,
	0xb4, 0xd5, 0x73, 0x40, 0xdf, 0xf4, 0x79, 0xfd, 0x06, 0x83, 0xfb, 0x07, 0x4e, 0xb4, 0x6d, 0x2d,
	0x7c, 0x05, 0x2d, 0x69, 0x64, 0x3c, 0xff, 0xc3, 0x33, 0x09, 0xfc, 0xdf, 0x0f, 0x76, 0x1f, 0xbf,
	0x83, 0x6e, 0x65, 0x50, 0xbc, 0x38, 0x6c, 0xdb, 0x32, 0xc9, 0xe5, 0x31, 0x4f, 0x13, 0x4b, 0x52,
	0x28, 0x83, 0x98, 0x14, 0x4d, 0x0b, 0x9a, 0x14, 0x86, 0x9b, 0x88, 0x85, 0x1f, 0x61, 0x60, 0x5e,
	0x29, 0x1a, 0xaf, 0xe8, 0xa0, 0x0f, 0x02, 0x72, 0x4c, 0xd2, 0x64, 0xac, 0xae, 0xd5, 0x64, 0xdc,
	0xf3, 0x84, 0xc9, 0xb8, 0xef, 0x04, 0x62, 0xe1, 0x35, 0x9c, 0xea, 0x5b, 0xc6, 0xa0, 0x29, 0x35,
	0xcd, 0x10, 0x5c, 0x1c, 0x3c, 0xab, 0xb2, 0x7c, 0xee, 0xa8, 0x7f, 0xee, 0xb3, 0x5f, 0x01, 0x00,
	0x00, 0xff, 0xff, 0xa3, 0x50, 0x7c, 0x46, 0x87, 0x05, 0x00, 0x00,
}
